# SIP-0002 Payment Routing

SIP-0002 is a description of a payment routing system between hosts in the Sia
network. It outlines in detail the requirements for such a system and proposes a
series of logical [steps](#implementation-steps) that can be implemented through
separate MRs in succession of one another to successfully accomplish the goal
outlined in the description.

## Description

Payment routing is the act of routing a payment through potentially a series of
interconnected hosts. This payment can originate from multiple types of sources,
be it renters, hosts or even non-Sia users eventually. Routing payments
effectively enables performing actions on hosts with which you don't necessarily
share an immediate link.

## Motivation

Payment routing serves as the basis for any use case where the end user does not
necessarily have an existing active file contract with the host they are
interacting with, nor do they have to be a Sia user per se. By being able to
forward payments on behalf of others, you can leverage already existing
contracts between hosts which act as payment channels.

This enables a myriad of possibilities for 3rd parties to build new and exiting
file publishing services atop of Sia. Including but not limited to: CDNs,
websites, file sharing, pay-per-view content streaming services and so on. These
all share the same base requirement which is the necessity of being able to make
a payment on behalf of somebody else.

It is interesting to note that in theory this system could support any action
that is currently possible on the host and requires payment, such as uploading
for example. However we are solely focussing on the download usecase for now.

## Concepts

### Host Topology

In order for hosts to forward payments amongst each other they will need to
connected and share a channel through which two-way payments are possible. A
host's topology is comprised of a list of hosts he knows how to reach. These
'connected hosts' are not necessarily immediate neighbours, it is very possible
they are one or even multiple hops away. The only thing that's important is that
the host knows how to reach it and forward a payment. Hosts advertize in their
topology both a price and a speed for every edge in their topology.

### Payment Channel

In order to route a payment there needs to be a payment vessel between two
hosts, ideally two-way. There is an obvious analogoy to the Lightning Network
here so it's probably not a bad idea to keep their model in mind while designing
this feature.

Through the use of file contracts, where we use a merkle root of 0 and
completely ignore the necessity to provide a storage proof, we can create such a
channel between two hosts. Opening up a channel would then mean creating a file
contract, this action requires interaction with the blockchain. However from
that point on, two hosts could move money back and forth by using
FileContractRevisions to update the state and both sign off on those.

A big concern for the time being is the trustlessness of this setup. However
through the fact that we use packetized payments, this risk is minimized as the
loss each party can incurr is minized by the fact we pay in very small
increments and losses are minimal should hosts go rogue.

#### Rebalancing

It is possible and to be expected that these "payment channels" get out of
balance and become one-sided after a while. This depletion of a channel's
capacity is an issue seeing as it means either a channel has to be reopened or
funds need to move in the other direction to rebalance the channel. Ideally we devise an algorithm that automatically rebalances these channels to
avoid the otherwise necessary renewal of a FileContract. However for the time
being the plan is to settle and recreate the FileContract when this event
occurs.

This paper on [Scalable Funding of MicroPayment Networks](#https://tik-old.ee.ethz.ch/file//a20a865ce40d40c8f942cf206a7cba96/Scalable_Funding_Of_Blockchain_Micropayment_Networks%20(1).pdf)
proposes a neat  solution that introduces the concept of Channel Factories.
Might be worth looking into in the future.

### Forwarded Payments

A forwarded payment is the introduction of payments which originate not from a
siacoin input nor a file contract but an outsourced place. Effectively making
payment in behalf of somebody that requested it. Forwarded payments are based on
a unique code the user provides, a 12 byte random number. They will call the
host they want to download data from and provide them with said code and tell
them to 'block for payment'. Meanwhile he routes payment through a known host by
telling them to 'receive forwarded payment' on his behalf, when this reaches a
host that knows about the code provided the block is lifted and the action
completes. For more detailed descriptions see the [RPC section](#RPCs)

## RPCs

There are 4 new RPC IDs required to cover all of the functionality outlined
above.

### `listTopology`

RPC called on host to retrieve the list of hosts that can be reached, together
with a price and latency for every edge in the graph. Renters can use this to
build up the entire network topology and make a decision on where to route the
payment

### `blockForForwardPayment`

Instead of all payments being required to come from either a siacoin input or by
being paid through the file contract, we should add an option to all of our
payment RPCs (including Form Contract and Renew Contract) to instead accept a
payment from an outsourced place.

This means that uploading could also happen from outsourced payments, though the
general intention is to enable downloads through outsourced payments, allowing
users to download data from hosts that they don't have file contracts with.

When requesting an outsourced payment, the user will provide a code (ideally
encrypted) that the host should wait for. If the code is a code that the host is
already waiting for (on some other connection),the host should return an error.
If the code is a unique code (which it should be, as a 12 byte random number),
then the host will block until either there has been a timeout, or until the
block is released by another rpc receiving the outsourced payment.

### `receiveForwardPayment`

This RPC is used by someone to pay on another person's behalf. The host keeps in
memory a list of payment codes where the host is awaiting payment. The host
stores both the code itself, and the amount of money that it requires from that
code.

In this RPC, the person on the other end of the contract makes a payment,
specifying the code that the payment is being made for. If the host recognizes
the code but the amount is insufficient, an error is returned. If the amount is
sufficient and the payment code is recognized, the host signs the payment and
then unlocks the blocking element on the other side of the payment code.

If the payment code is not recognized, the host assumes that this is prepayment
for a future download that is going to be made. The host will add this code to
the list of codes that will allow the host to unblock right away, saving the
code itself and the corresponding value. The host will return to the payment
provider a special code indicating that this code is being accepted as a
pre-payment. The host will also provide a timeout, after which the payment is
void. This behavior is important for CDN functionality, allowing websites to
pre-pay for user downloads that will happen in the future.

### `forwardPayment`

This RPC is used to tell a host to forward a payment (presumably to another
host). A payment is made, and a payment code is provided. The host will then
take a small fee, and use a payment channel that they have to forward the
payment to the provided destination.

It's entirely possible that the destination host is blocking on their own
'Forward Payment' RPC, which means a renter that knows enough of the routing
table can easily orchestrate a multi-hop outsourced payment.

## Routing Example

The following is a graphical overview of the requests necessary to forward a
payment in a multi-hop payment route. In the diagram below we assume the renter
is trying to download a piece of data from H3 however he only has an active
contract with H1.

Please note that the underlying system will be built in such a way that the
renter does not need to perform these calls in a certain order. They can be
fired in whichever sequence, the code should be able to await a future request.
However for sake of reasoning these requests happen in a logical sequential
order.

1. The renter builds in memory a complete topology of the network, he does this
   by calling `listTopology` on every host he is connected with and builds up
   the graph in memory. This is not shown on the diagram for simplicity.

2. When he has decided on a route that is cheapest (or perhaps more expensive
   but faster) he will perform a set of calls to every hop in the route, here
   the route consists of H1->H2->H3.

3. He makes a request to H3 to `blockForForwardPayment`, providing a code, cost
   and instruction he wants executed. In this case a download

4. He sends `forwardPayment` requests to every intermediate host in the route,
   again supplying the same code but every time a different cost as the fees
   subtracted very for every host

5. Lastly he sends a `forwardPayment` to the first host in the route.

6. Upon receiving payment a host will either unblock an action if it had been
   blockedForForwardPayment, or it will call `receiveForwardPayment` on the next
   host in the route

![Screenshot](../assets/paymentrouting.png)

## Implementation Steps

1. add RPCs
2. hosts must have forwards
3. renter can build topology
4. pull it all together

[TODO: add MRs for every step]
