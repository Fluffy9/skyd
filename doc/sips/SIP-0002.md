# SIP-0002 Payment Routing

SIP-0002 is a description of a payment routing system between hosts in the Sia
network. It outlines in detail the requirements for such a system and proposes a
series of logical [steps](#implementation-steps) that can be implemented through
separate MRs in succession of one another to successfully accomplish the goal
outlined in the description.

## Description

Payment routing is the act of routing a payment through potentially a series of
interconnected hosts. This payment can originate from multiple types of sources,
be it renters, hosts or eventually even non-Sia users. Routing payments
effectively enables performing actions on hosts with which you don't necessarily
share an immediate payment link.

## Motivation

Two of the most attractive use cases for Sia are filesharing and content
distribution. For both cases, a user will often be required to make a
micropayment to a host, where they don't have a pre-existing payment channel to
that host. By implementing payment routing we enable anybody that has an
existing payment channel with a host, to pay those hosts on behalf of somebody
else. These pre-paid actions can then be reclaimed by anyone who owns the
payment code. This way a user can fulfil an action on a host without necessarily
paying for it in that same requests. Which has been the case up until now.

## Concepts

### Host Topology

In order for hosts to forward payments amongst each other they will need to be
connected and share some form of payment channel. A host's topology is comprised
of a list of hosts he is connected with. These 'connected hosts' are not
necessarily immediate neighbours, it is very possible they are one or even
multiple hops away. The only thing that's important is that the host knows how
to reach it and forward a payment to it, either directly over a payment channel
our through a series of hops. Hosts advertize in their topology both a price and
a latency for every host.

### Payment Code

A payment code is the unique 16 bytes number that represents an action on the
host that may or may not have already been pre-paid by somebody else in behalf
of the user requesting the action to be performed.

Instead of all payments being required to come from either a siacoin input or by
being paid through the file contract, we should add an option to all of our
payment RPCs (including Form Contract and Renew Contract) to instead accept an
outsourced payment by supplying it with a payment code.

### Payment Channel

In order to route a payment there needs to be a payment vessel between two
hosts, ideally two-way but this is no strict requirement, it can be one way.

Through the use of file contracts, where we use a merkle root of 0 and
completely ignore the necessity to provide a storage proof, we can create such a
channel between two hosts. Opening up a channel would then mean creating a file
contract, this action requires interaction with the blockchain. However from
that point on, two hosts could move money back and forth by using
FileContractRevisions to update the state and both sign off on those. Much like
in the Lightning Network they would both have signed transactions they could
submit should they want to close out on the contract at any point in time for
any reason.

A slight concern for the time being is the trustlessness of this setup. However
through the fact that we use packetized payments, this risk is minimized as the
loss each party can incurr is minized by the fact we pay in very small
increments, and thus losses are negligible should hosts go rogue.

#### Rebalancing

It is possible and to be expected that these "payment channels" get out of
balance and become one-sided after a while. This depletion of a channel's
capacity is an issue seeing as it means either a channel has to be reopened or
funds need to move in the other direction to rebalance the channel. Ideally we
devise an algorithm that automatically rebalances these channels to avoid the
otherwise necessary renewal of a FileContract. However for the time being the
plan is to settle the contract and recreate it when this event occurs.

#### Pricing

Hosts that have a payment channel open with another host will have to publish
prices for routing a payment. These prices are made public through the host's
topology. We have a number of options here on how to implement this pricing
schedule. Some thoughts/requirements

- Hosts should be able to arbitrarily set the fee they want to charge for
  payment routing
- Seeing as a depleted channel requires a renewal of a contract, and thus
  requires fees to be paid, it might make sense to charge more if you want to
  wire a payment through a channel that will get depleted as the result of it

### Forwarded Payments

A forwarded payment is the introduction of payments which originate not from a
siacoin input nor a file contract but an outsourced place. Effectively making
payment in behalf of somebody that requested it. Forwarded payments are based on
a unique code the user provides, a 16 byte random number. They will call the
host they want to download data from and provide them with said code telling
them to 'block for payment'. Meanwhile payment is routed through a known host by
calling 'receive forwarded payment' on his behalf, when this reaches a
host that knows about the code provided the block is lifted and the action
completes. For more detailed descriptions see the [RPC section](#RPCs)

## RPCs

To cover all functionality required for payment routing we will introduce a
couple of new RPC instructions.

### `listTopology`

Called on the host to retrieve the list of hosts that it can reach, together
with a routing cost and latency for every host. The caller can use this to build
up the entire network topology and make a decision on how to route the payment.

```Go
// Topology describes the set of hosts a host is connected to and is able to
// route a payment towards.
type Topology struct {
    host    PublicKeyString,    `json:"host"`
    links   []Link       `json:"links"`
}

// Link defines a payment link between two hosts, it has a certain cost which is
// a variable cost of routing and a latency
type Link struct {
    host        PublicKeyString,    `json:"host"`
    cost        types.Currency      `json:"cost"`
    latency     time.Duration,      `json:"latency"`
}
```

### `forwardPayment`

This RPC is used to instruct a host to forward a payment (presumably to another
host). A payment is made, and a payment code is provided. The host will then
take a small fee, and use a payment channel that they have to forward the
payment to the provided destination.

A forward payment RPC always contains payment instructions, along with a
destination host on which to call receivePayment. Providing the host knows about
the destionation host, a forward RPC call is always succeeded with a
`receivePayment` RPC to the destination host. Receive payment in turns usually
unlocks an instruction which had been blocked until payment was received.

### `blockForPayment` and `receivePayment`

The `blockForPayment` and `receivePayment` are arguably the most important RPC
calls for this feature. We describe them together because they are fundamentally
entangled with one another. As we will outline they need each other's
information in order to be properly fulfilled or processed.

Block for payment is named as such because it will effectively block execution
of a certain RPC instruction until it has received payment to fulfil said
instruction. Receive payment then on the other hand has the power to lift such a
block and effectively execute the awaiting instruction. The `blockForPayment`
has supplied us with a payment code and hash, the `receivePayment` RPC however
supplies us with the preimage of said hash. Only if those match the contents of
the preimage image are executed, which is an RPC instruction set.

Let's look at everything that can happen when either of these calls is received
by a host:

When a `blockForPayment` RPC call is received the host will either:  
a) block execution of the given RPC instruction until payment is made, if the
payment code is unknown. Please note this block is uplifted if a predefined
timeout expires  
b) return an error if the provided payment code is already known to the
host but the stored preimage does not equal the provided hash  
c) execute the given RPC instruction if the payment code is already known to the
host and the given hash matches the stored preimage

When a `receivePayment` RPC call is done on a host, it will either:  
a) return an error, if payment code is known but data is invalid. This happens
when the given data (preimage) for a certain payment code does not correspond
with the hash provided by `blockForPayment`, due to an insufficient amount for
example  
b) receive payment and unblock the corresponding RPC call, if payment code is
known and data is valid  
c) treat payment as pre-paid, if payment code is unknown. This will effectively
process the payment and keep all necessary information in memory and await a
future `blockForPayment` call which will resolve immediately if the payment code
is known and the given hash is the hash resulting from the preimage.

## Routing Example

The following is a graphical overview of the requests necessary to forward a
payment in a multi-hop payment route. In the diagram below we assume the renter
is trying to download from H3 however he only has an active
contract with H1.

Please note that the underlying system will be built in such a way that the
renter does not need to perform these calls sequentially, or in any order for
that matter. Instead the renter will fire off all of these requests in
parallell.

We assume the renter has used the `listTopology` RPC call to query all the hosts
he is connected to and build a topology of the network. This way he found out he
can reach H3 through H1.

1. Renter sends a `blockForPayment` RPC request to H3, providing a payment
   code and hash which should correspond with a preimage delivered by
   `receivePayment`. It is this preimage that contains the instruction RPC set
   that needs to be paid for, and which will execute when this payment has been
   received. In this case the corresonding preimage at H3 contains the download
   RPC instructions.

2. Renter sends a `blockForPayment` RPC request to H2, providing a payment
   code and hash which should correspond with a preimage delivered by
   `receivePayment`. It is this preimage that contains the instruction RPC set
   that needs to be paid for, and which will execute when this payment has been
   received. In this case the corresonding preimage at H2 contains the forward
   RPC instructions.

3. Renter sends a `forwardPayment` RPC request to H1, providing a payment code,
   a destination host and a preimage. This preimage will contain RPC
   instructions that require the payment.

4. H1 will accept the payment and forward it by calling the `receivePayment` RPC
   on the destination host (in this case H2) given the supplied preimage.

5. H2 will receive this `receivePayment` RPC and realize it had a
   `blockForPayment` with a matching payment code, and more importantly the
   given preimage hashes to the already supplied hash. If so it will unblock
   that as it has now received payment. The unblocked RPC is a `forwardPayment`
   call instructing it to send payment to H3.

6. H3 will receive this `receivePayment` RPC and realize it had a
   `blockForPayment` with a matching payment code, and more importantly given
   preimage hashes to the already supplied hash. It will unblock that call
   as it has now received payment. The unblocked RPC is a `download` call
   originating from the renter.

![Screenshot](../assets/paymentrouting.png)

## Implementation Steps

1. Extend RPC instruction set

2. hosts must have forwards

3. renter can build topology

4. pull it all together

[TODO: add MRs for every step]
