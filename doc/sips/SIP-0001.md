# SIP-0001 - Merklized Data Machine

SIP-0001 is a description of a virtual machine - the Merklized Data Machine
(MDM) - that executes instructions on the data in a Sia file contract. The file
contract tracks the size and Merkle root of the underlying data, which the MDM
will update when running instructions that modify the file contract data. Each
instruction can optionally produce a cryptographic proof that the instruction
was executed honestly. Every instruction has an execution cost, and instructions
are batched into atomic sets called 'programs' that are either entirely applied
or are not applied at all.

## Motivation and Rationale

The renter is required to perform increasingly sophisticated operations on the
host, especially as the renter is introducting new features such as garbage
collection, partial uploads, and file modifications. Further looking features
are even more complex than these.

Currently, each time the Sia team has chosen to add a new feature, the
renter-host protocol has needed an extension to support the feature. This not
only slows down Sia development, it presents a barrier to third parties looking
to develop novel applications on top of Sia.

The purpose of the MDM is to substantially increase the flexibility of the
renter-host protocol, enabling the renter to perform significantly more complex
behaviors and introduce novel ideas without needing any protocol extensions.
These more complex behaviors are enabled by a rich set of composable base
operations provided by the MDM.

## Machine Specification

The Merklized Data Machine (MDM) is a virtual machine on a host that performs
operations on the data in a Sia file contract. The data in the contract is
tracked by a size and a Merkle root. The Sia consensus protocol breaks the
contract data into 64 byte 'segments', where each segment is a leaf of the
Merkle tree that builds into the Merkle root. As the MDM operates on the data,
the size and Merkle root of the file contract will be updated, and optionally
proofs can be produced proving that the operations were executed faithfully.

### Sectors

The MDM breaks the contract data into 4 MiB 'sectors'. A sector's Merkle root
can be computed by treating each of the 65,536 segments as a leaf in a Merkle
tree and combining them into the 'sector root'. Because the sector root is
computed using the same leaves as the contract Merkle root, the sector roots can
themselves be used to compute the contract Merkle root. The MDM requires that
the contract size be a multiple of the sector size.

The host is explicitly expected to store all data within a sector continuously
on disk. Other than this requirement, contract data is not expected to be stored
continuously. This requirement allows the MDM to have predicatable performance
and a preditable execution cost, while allowing the host to optimize the
placement of multiple file contracts across multiple disks.

The host maintains a lookup table that maps from each sector root to the
location on disk where the data is stored. This lookup table is global to the
entire host, allowing callers to query data by sector root even if the caller
does not have access to the contract manages the sector. The host also allows
callers to look up sector roots by providing a contract id and a sector offset
within the contract, allowing callers to see data that is held at a specific
location within a contract even if they do not know the sector root.

Renters that wish to maintain privacy are expected to encrypt their data. The
host is not expected to enforce any access controls over a contract. A contract
cannot be updated without a signature from the owner of the data, however a
contrant can be accessed without a signature from the owner of the data.

The host itself does not have a mapping from sector root to the contract that
contains the sector. This means that data cannot be modified merely by knowing
the sector root, the caller also needs to know the corresponding contract and
the location of the sector within the contract, and additionally needs to have
ownership of the contract to sign any update.

### Programs

The MDM has 'instructions' that can be executed, each instruction performing a
distinct operation on the contract data. Every instruction starts with an
initial Merkle root and size and produces an updated Merkle root and size.

Instructions are batched together into a 'program'. Within a program, each
instruction will pass its updated Merkle root and file contract size to the next
instruction. The final instruction will pass the final Merkle root and contract
size to the MDM to be placed into an updated file contract revision that needs
to be signed by the host and by the contract owner. If the final contract size
and Merkle root are identical to the original, no signature is needed from the
contract owner.

#### Input

The program has a single data field which instructions use to specify their
input. Having a single data field allows multiple instructions to re-use the
same input, which can be helpful for compression. Having a single program data
field also allows possible future extensions to the MDM that would modify the
program data, substantially boosting the power of the MDM. No such instructions
exist within the SIP-0001 specification.

A program itself takes the following form:

```go
// An Operand is a pointer to input for the instruction. The input itself lies
// within the program data.
type Operand struct {
	Offset uint64
	Len    uint64
}

type InstructionInfo struct {
	// The op code tells the MDM how to interpret the instruciton.
	OpCode types.Specifier

	// Pointers to the inputs of the instructions within the program data. The
	// total number of operands is specific to each instruction.
	Operands []Operand

	// If set to 'true', the InstructionOuput will contain a proof that allows
	// the caller to verify the execution of the instruction without needing the
	// file contract data.
	ProofRequired bool
}

type Program struct {
	// The contract specifies which contract is being modified by the MDM. The
	// MDM also supports a special 'ReadOnly' mode, which can be triggered by
	// setting 'Contract' to the empty value.
	Contract types.FileContractID

	Instructions []InstructionInfo
	Data         []byte
}
```

Each instruction points to areas of the program data. Program data is uploaded
sequentially, and instructions will be executed as soon as all of the program
data necessary for that instruction is available. This allows the program to
begin exection even before the entire program is uploaded.

#### Output

As the program executes, each instruction will produce output to be sent to the
caller. The output will be sent to the caller as the program executes. This
allows the program output to begin sending to the caller even as the program is
still uploading and executing.

Instruction outputs take the following form:

```go
type InstructionOutput struct {
	// The error will be set to nil unless the instruction experienced an error
	// during execution. If the instruction did experience an error during
	// execution, the program will halt at this instruction and no changes will
	// be committed.
	Error error

	// The proof will be set to nil if there was an error, and also if no proof
	// was requested by the caller. Using only the proof, the caller will be
	// able to compute the next Merkle root and size of the contract.
	Proof []crypto.Hash

	// The output will be set to nil unless the instruction produces output for
	// the caller. One example of such an instruction would be 'Read()'. If
	// there was an error during execution, the output will be nil.
	Output []byte
}
```

Though the outputs of the program are sent as the program executes,
modifications to the contract data are not committed until the caller has had
the chance to sign the final state of the contract following the termination of
the program. If the caller approves the final state of the contract data, all
changes will be committed atomically.

If the caller has all of the required metadata already and does not need proofs
to know the final state of the contract, the caller can send a signed version of
the updated contract even before the program is done executing. The host can
still experience an error during execution however, meaning both the caller and
the host need to be able to handle the edge case where the contract is sent
pre-signed and yet the program fails.

#### Interruption

A program being executed may be interrupted. If an interrupt signal is received,
the host will stop executing instructions, and will stop sending any output
which has already been created. Because of latency between the caller and the
host, the interrupt signal may arrive late. The host will acknowledge the
interrupt even if the signal arrives too late to be productive. If a contract
update was pre-signed, sending an interrupt may fail to prevent the update from
being applied.

Interrupts are particularly useful when reading data from the file contract. In
the example case of video streaming, the renter will be attempting to cache data
to improve the user experience. If the user seeks to a new part of the stream,
the renter may with to cancel a read operation to fill the cache so that
bandwidth is freed up to fetch data that is actively blocking the user from
seeing the video stream.

#### Encoding

Because the renter may receive an interrupt at any time, and because the host
may have to send an interrupt at any time, the rest of the input and output
needs to be wrapped in some sort of packet that indicates "not an interrupt".
This slightly complicates the otherwise simple encoding scheme.

```
// The packet wraps a set of data being sent either from the caller to the 
type MDMPacket struct {
	// Types:
	//    1: Interrupt
	//    2: Standard
	//
	// The only valid values are '1' and '2'. '0' is intentionally left as an
	// error to detect cases where a value is not properly initialized. An
	// interrupt will always have length of 0. Standard output being sent from
	// the caller means that the next 'length' bytes of the Program are being
	// sent, and standard output from the host means that the next 'length'
	// bytes of the output are being sent.
	//
	// Using smaller MDMPackets reduces efficiency, but creates more
	// opportunities to send an interrupt. An interrupt is not allowed to be
	// sent in the middle of sending another packet.
	Type   uint64
	Length uint64
}
```

Within a packet, all data is encoded using the Sia encoding format.

### Execution Modes

#### ReadOnly Mode

If a program specifies an empty value for the 'Contract', the MDM will execute
in ReadOnly mode. No lock is needed, no signatures are needed, and many ReadOnly
MDMs can execute simultaneously. ReadOnly MDM instances can even execute in
paralell to ReadWrite MDMs operating on the same data.

An immediate advantage to supporting a ReadOnly mode that is non-exclusive with
ReadWrite mode is that a renter can upload and download from the same contract
at the same time, allowing a single host to simultaneously saturate both the
upload bandwidth and the download bandwidth of a renter on a single connection.
This also greatly improves the responsiveness of the renter for streaming
downloads when a user is currently uploading large amounts of data.

Another advantage of ReadOnly modes is that data publishing is better supported.
Many clients can read the same data at once, and a publisher can update the data
concurrently without disrupting reads that are in progress or causing hiccups
for their users.

Race conditions between ReadOnly MDMs and ReadWrite MDMs are handled at the
instruction level.

#### ReadWrite Mode

An MDM can be set to run in ReadWrite mode by setting the 'Contract' value of
the program equal to an existing file contract ID. When locking the contract,
the caller must provide a signature that proves they have knowledge of the
private key of the contract. An MDM running in ReadWrite mode has full access to
all of the instructions in the MDM, including the ones that modify the contract
data. Before the MDM starts running, an exclusive lock must be obtained on the
contract that is being modified. The exclusive lock will not block ReadOnly
MDMs, however it will block parallel attempts to PayByContract or RenewContract
on the same contract.

The contract lock will prevent all other processes from updating the contract
because other processes that can update the contract may change the filesize or
Merkle root, which would invalidate any updates and proofs made by the ReadWrite
MDM.

The lock around the contract is held until the program is completed. If the
caller has sent a valid presigned a file contract covering the update, the lock
will be released as soon as the changes have committed. If the caller did not
send a pre-signed file contract, the lock will be held after the updated
contract is sent to the caller for a signature, until the caller either accepts
and returns a countersigned contract, rejects, or times out.

In the event of a time-out or rejection, the changes are aborted and the lock is
dropped.

### Resource Consumption and Resource Limits

The MDM consumes resources on the host. To achieve fairness between programs and
protect the host against Denial of Service attacks, several resources are
tracked as the MDM executes, and each program is run with a limit for total
consumption of each resource.

Each instruction needs to be able to pre-compute the total resource requirements
for execution immediately prior to execution. If executing the instruction would
put the MDM over any of its resource limits, the program will halt with an
error.

Five total resources are tracked. The host is able to price each resource, and
the resources are chosen to allow hosts to roughly put a fair price on the
execution of different types of programs even when each host is operating on
different types of hardware. The five resources are:

* Memory Consumption
* Compute Power
* Disk Accesses
* Disk Reads
* Disk Writes

The bandwidth resources are tracked at the networking layer, and are therefore
ignored by the MDM.

All resources are tracked cumulatively, meaning that the totals count up as each
instruction executes by the cost of that instruction. It is assumed that memory
will not be able to be reclaimed until after the program has terminated. In
particular, the output of an instruction may stick around long after the
instruction executes because the output will be put in a queue to be sent to the
caller, and this queue may take a while to process.

Once the program has completed, the costs will be returned to the networking
layer, which also handles pricing and will be responsible for charging the
renter for the resources used.

Instantiating the MDM has the following costs:

* Disk Access:         1 access
* Disk Read:           0 bytes
* Disk Write:          0 bytes
* Memory Consumption:  4 MiB + len(encodedProgram)
* Compute Power:       1 unit

## Supported Instructions

Notation: the instructions are written as functions that take multiple variables
as input. The variables are assumed to have an obvious encoding into the
operands. If instruction requires an interaction with the program data, the
variable will be prefixed by 'pd'. If the instruction writes to the program
data, the destination will be a []byte prefixed by 'wpd'. The operands will also
need to include information about where to find the 'pd' and 'wpd' variables
within the program data.

If the instruction has data output that is sent to the user, the instruction
definition will return a []byte.

TODO: Formal specification for encoding instruction inputs into operands.

### Read(length uint64, pdOffset uint64) []byte

Read will read 'length' bytes from the contract, starting from the provided
offset. The request must exist fully within the bounds of the contract.

The output of Read is the 'length' bytes that appear in the contract starting
from the provided offset.

Cost:
* Disk Accesses:    2 + (length / sectorSize)
* Disk Read:        length
* Disk Write:       0
* Computation Cost: log2(contractSize/64)

### ReadSector(length uint64, pdOffset uint64, pdRoot crypto.Hash) []byte

ReadSector will read data from the sector with the sector root 'root'.
ReadSector will read 'length' bytes from the sector starting from the provided
offset. The request must exist fully within the bounds of the sector.

The output of ReadSector is the 'length' bytes that appear in the sector
starting from the provided offset.

Cost:
* Disk Accesses:    1
* Disk Read:        length
* Disk Write:       0
* Computation Cost: log2(contractSize/64)

### Write(pdOffset uint64, pdData []byte)

Write will write 'pdData' at offset 'offset' within the contract, overwriting
any data that already exists at that location. Write must not go beyond the
bounds of the existing file contract data.

Cost:
* Disk Accesses:    2 + (len(pdData) / sectorSize)
* Disk Read:        0
* Disk Write:       len(pdData)
* Computation Cost: log2(contractSize/64)

### WriteSector(root crypto.Hash, offset uint64, pdData []byte)

Write will write 'pdData' at offset 'offset' within the sector, overwriting any
data that already exists at that location. Write must not go beyond the bounds
of the sector.

Cost:
* Disk Accesses:    1
* Disk Read:        len(pdData)
* Disk Write:       0
* Computation Cost: log2(contractSize/64)

### Copy(size, destOffset, sourceOffset uint64)

Copy will copy the data from sourceOffset to destOffset, overwriting existing
data. Copy cannot copy outside the boundary of the existing file contract.

Cost:
* Disk Accesses:    4 + 2 * (size / sectorSize)
* Disk Read:        size
* Disk Write:       size
* Computation Cost: 2 * log2(contractSize/64)

### CopySector(size, destOffset, sourceOffset uint64, destRoot, sourceRoot crypto.Hash)

CopySector will copy data from the sourceRoot at the sourceOffset to the
destRoot at the destOffset. The copy is not allowed to go outside the range of
either sector.

Cost:
* Disk Accesses:    2
* Disk Read:        size
* Disk Write:       size
* Computation Cost: 2 * log2(contractSize/64)

### Swap(size, offset1, offset2 uint64)

Swap will read data from offset1, then read data from offset2, then write the
data from offset1 to offset2, then write the data from offset2 to offset1.

TODO: Should the offsets be allowed to overlap? Probably not.

Cost:
* Disk Accesses:    4 + 2 * (size / sectorSize)
* Disk Read:        size
* Disk Write:       size
* Computation Cost: 2 * log2(contractSize/64)

### Truncate(newSize uint64)

Truncate will change the size of the contract data to be equal to the newSize,
throwing away data on the tail of the file if the new size is smaller, and
appending zeroes to the end of the contract data if the new size is larger. If
newSize is equal to the current size of the contract data, this instruction is a
no-op.

'newSize' must be a multiple of the sectorSize.

Cost:
* Disk Accesses:    1
* Disk Read:        0
* Disk Write:       0
* Computation Cost: log2(contractSize/64)

### RenewContract()

TODO: This operation has extra overheads + costs, not sure how to handle that.
We need Renew to be inside of the MDM because the new file contract needs to be
created atomically with dropping garbage sectors. The renew operation also needs
to zero out the data in the previous contract / previous revision, and that
needs to happen in a single transaction.

Cost:
* Disk Accesses:    1
* Disk Read:        0
* Disk Write:       0
* Computation Cost: log2(contractSize/64)

## Example Programs

### Delete A Sector

This program deletes sector 7 from a contract with 250 sectors, where the final
49 sectors are garbage. Metadata in the leading sector needs to be updated to
indicate the new length of the garbage.

Instructions {
	Swap(2^22, 7*2^22, 200*2^22)
	Write(4096, payload[:4096])
}

### TODO: Write a similar program as above

except read from the metadata to know where the swap should happen. This may
result in the swap operands being modified - the size needs to be an operand,
but offset1 and offset2 could actually be payload variables. Another instruction
could read from the metadata and then modify the payload to tell swap how to
swap out the garbage.

### Renew a File Contract with Garbage

This program renews a file contract that has 250 sectors, but the final 50
sectors are garbage.

Instructions {
	Truncate(200*2^22)
	Renew()
}

### TODO:

Write some program that relates to updating multiple contracts simultanously,
preserving ACID properties. Or maybe some program that would be related /
necessary to doing continuous backup.

### TODO:

Write some program related to filesystem trasversal, such that the renter can
read data without needing multiple round trips.
