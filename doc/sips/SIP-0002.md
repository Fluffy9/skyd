# SIP-0002 Ephemeral Accounts

## Description

Ephemeral accounts are a service offered by hosts that allow users to connect a
balance to a pubkey. Users can deposit funds into an ephemeral account with a
host and then later use the funds to transact with the host. The most common
transactions will be uploading and downloading data, however any RPC that
requires payment will support receiving payment from an ephemeral account.

Each host has a separate set of ephemeral accounts, and each host is fully
trusted to honestly track the balances of the accounts. Users who keep ephemeral
accounts with a host will be able to verify themselves that a host is honestly
reporting the balance of an ephemeral account, however users have no recourse if
a host chooses to steal all of the money in an ephemeral account or otherwise
deny that the account exists. For this reason, users should only keep tiny
balances in ephemeral accounts and users should refill the ephemeral accounts
frequently, even on the order of multiple times per minute.

## Motivation

The main purpose of ephemeral accounts is to eliminate a key bottleneck in
download latency. The advantage it offers is that we can front-load our latency.
If it takes 6 hops and 2.5 seconds to pay host X, we can perform that payment in
advance of needing to download anything from host X by opening an ephemeral
account. That way, when we actually want to download data from the host, we can
enjoy downloading from the host in a single round trip that only needs to
communicate with the host, and we save ourselves from needing to do the 6 hop
routing in real time.

## Ephemeral Account

An ephemeral account is a balance linked to a pubkey. These accounts reside on
the host. The account owner fully entrusts the money with the host, he has no
recourse at all if the host decides to steal the funds.

The name 'ephemeral account' stems from the fact that hosts maintain a relaxed
consistency and durability of these accounts. This effectively enables us to do
perform the I/O asynchronously to the transaction, instead of needing to commit
a change before completing the transaction. This eliminates a key bottleneck in
download latency, and also enables much greater parallelism on downloads,
allowing a speed and flexibility that cannot be achieved with traditional
payment channels.

### Withdrawal Message

In order to spend from the ephemeral account, the account owner will construct a
withdrawal message along with a signature. This way the host can verify the
message sender is the owner of the ephemeral account.

Withdrawal messages contain an expiry. This is the blockheight at which the
withdrawal message is no longer valid. This expiry can not be in the past, nor
can it be too far into the future. If a withdrawal message expires, the renter
can just make a new one.

Aside from an expiry, the message should also contain an account id, amount to
spend and a nonce. The nonce is an arbitrary number making the message unique.

### Fingerprint

To ensure a withdrawal message is only spent once, the host will keep track of
its fingerprint. The fingerprint is the hash of the withdrawal message. The host
holds on to these fingerprints until they expire. By doing so, the host prevents
replay attacks as the account owner won't be able to spend the same withdrawal
twice.

### Persistence Model

The ephemeral account data is comprised of two main parts. On the one side you
have the account's pubkey and the balance, and on the other hand we have a list
of fingerprints generated by withdrawals that happened it the past. Due to their
nature, fingerprints can be kept separate from the account details. This will
have some performance benefits, as this means that fingerprints can be saved
using append-only file persistence.

All account balances are kept in a single accounts persist file. Because
accounts get updated so frequenty, we do not want to update the entire file
every time an account balance gets updated. For this reason, accounts are fixed
in size and get persisted to disk at a fixed location. This allows to update an
account's data without having to lock the entire file.

The fingerprints are kept in two files, which we will call 'buckets' from here
on out. Fingerprints expire at a certain blockheight, this means that we have to
keep track of them until that blockheight, and can safely purge them from those
buckets as soon as we've reached that blockheight. The buckets are called
'current' and 'next'.

The current bucket contains all fingerprints which expire within the current
block range. This period is calculated by dividing the current block height by
the size of the bucket, and rounding upward. So if block range is 20, and
current blockheight is 34, the current block period is 20-40. Anything over 40
gets persisted in the next bucket. Anything over 60 is considered too far into
the future.

It will be important to rotate in-memory fingerprints in a way that we can do it
in constant time. Anyhing less than that will prove way too slow in practice and
would lock up a host's CPU.

The persisting of these values happen asynchronously to the action being
performed on the account. A spend action can complete before the updated balance
hits the disk.

### Ephemeral Account Balance

Accounts have a maximum balance. This is a safety measure that protects the
host. If the host were to go offline, it would lose part of its state. Renters
could pick up on this and attempt to double spend. By limiting the maximum
account balance we protect the total amount of money the host is on the hook
for.

### Ephemeral Account Expiry

If an account has been inactive for a period of 7 days, the host will prune it
from his accounts list. This will effectively expire the account, along with all
the money that was associated to it.

Accounts expire due to their nature, the money that gets deposited into those
accounts is meant to be used almost instantaneously. It can not be expected of
hosts to keep track of these accounts for a long period of time. 7 days seems
more than fair.

### Blocking Spends

Spending from an ephemeral account is a potentially blocking action. It will
block when the account is not well enough funded. This block either expires
after a timeout, or is lifted by a deposit into the account you are spending
from. This is a latency optimisation and allows to easily orchestrate calls that
involve multiple hosts. This will prove useful for forwarding payment.

Blocked calls are unblocked by priority. Currently priority is defined by the
time at which the call came in. This might be extended to allow download calls
to take precedence over other calls.

## Host Internal Settings

### EphemeralAccountMaxBalance

The maximum ephemeral account balance is configurable through the internal host
setting called `MaxEphemeralAccountBalance`. It defaults to the
`SiacoinPrecision`, which is how many base units fit into a single siacoin,
which is 10^24.

### MaxUnsavedDelta

To increase performance, the host will allow a user to withdraw from an
ephemeral without requiring the user to wait until the host has persisted the
withdrawal to complete a transaction. This allows the user to perform actions
such as downloading with significantly less latency. This also means that if the
host loses power at that exact moment, the host will forget that the user has
spent money and the user will be able to spend that money again. The host can
configure the amount of money he is willing to risk due to this asynchronous
persist model through the `maxunsaveddelta` setting.