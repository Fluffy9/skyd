# SIP-0003: RPC Payment Method

## Description

To execute an RPC method on a host, payment is required. Some calls only require
the caller to cover the base RPC price, while others have more intricate pricing
schemes.

Ephemeral accounts serve as a new form of payment method. Alongside with file
contracts there are two methods to pay the host. This payment logic will be
identical across all RPCs.

SIP-0003 proposes to isolate all logic that deals with extract payment for an
RPC into a standalone library function. This function can get called by every
RPC and will simply return success or failure. It obfuscates all necessary
communcation that goes prior making a successful payment to the host.

## Motivation

There are two ways to pay a host. If you and the host share a file contract, it
can be used to pay the host by updating the revision in which you allocate more
money to the host and signing it. If you have an ephemeral account on said host,
it can be used to pay the host by signing a message using the ephemeral
account's private key. We will call these types of payment 'PayByContract' and
'PayByEphemeralAccount' respectively.

The communication needed to make such a payment, will be identical across all
RPCs. That is why we isolate it into a library function that takes care of
payment. Every RPPC that requires payment will call it, and will be able to
either continue or abort.

## Payment Methods

### PayByContract

Pay by contract uses a file contract it has with the host to make payment. The
contract through which to make payment is defined by the contract id. This id is
implicitly defined on the session. If the id is blank or bad, we will return an
error and the RPC fails to complete.

Paying by contract happens through updating the revision. The caller presents
the host with an updated revision and signature. When the host accepts the
revision, the RPC continues. When the host denies the revision, the RPC aborts.

### PayByEphemeralAccount

Pay by ephemeral account uses an ephemeral account to make payment. The caller
will specify all details in a withdrawal message, and provide a signature
alongside the message. By signing it with the private key linked to the
ephemeral account, he proves ownership and thus allows payment to be made from
that account.

Withdrawal messages contain an expiry. This is the blockheight at which the
withdrawal message expires and is no longer valid. This expiry can not be in the
past, nor can it be too far into the future.

The message contains a nonce, making it unique.

The hash of the withdrawal message is called the fingerprint. It is kept until
the withdrawal message expires. It is used to prevent replay attacks, seeing as
we keep all fingerprints in a lookup table until they expire, we can use it to
prevent the same message from being spent twice.

## Design (WIP)

The library function that takes care of all payment detail is called
`extractPaymentForRPC`. It will be called by all RPCs before they execute, and
simply return whether or not payment was accepted, and if so how much.

If the function returns an error, or if the payment was not accepted, the RPC
simply aborts.

```Go
func extractPaymentForRPC(conn net.Conn) (accepted bool, amountPaid 
types.Currency, err error)

type withdrawalMessage {
    id      types.SiaPublicKey
    expiry  types.BlockHeight
    amount  types.Currency
    nonce   int
}

type PayByEphemeralAccountRequest {
    message     withdrawalMessage
    signature   crypto.Signature
}

type PayByEphemeralAccountResponse {
    amount  types.Currency
    AMResponse
}

type PayByContractRequest { 
    Revision
    Signature
}

type PayByContractResponse {
    Amount
    AcceptRejectMessage
    Signature
}
```

## Session (NOTE: outside of SIP-0003 and should be implemented separately)

A session is created by first perform a Diffie-Hellman handshake. After the key
exchange the contract id is read from the connection. This contract id is kept
on the session and does not change for the lifetime of the session. The host
will update the RPC price table, this will also be kept on the session object so
the caller can consult the host's prices. The caller will ask the host to
refresh its prices as soon as the TTL expires.

### Contract Lock

When payment is made by contract, a lock on the contract defined in the session
is acquired. This opposed to acquiring and maintaining the lock for the duration
of the entire session. The contract id is defined on the session when the
session gets created. The contract id remains the same for the duration of the
session. The lock on the contract is kept for the duration of the RPC.

### RPC Price Table

The RPC price table is kept on the session. This table contains pricing details
for every action that requires payment on the host. This data is dynamic, and is
valid until a certain timestamp.

The host will update this RPC price table upon request. If the price table is
out of date, the host will return an error. It is up to the renter to trigger a
refresh.