# SIP-0002 Ephemeral Accounts

## Description

Ephemeral accounts are a service offered by hosts that allow users to connect a
balance to a pubkey. Users can deposit funds into an ephemeral account with a
host and then later use the funds to transact with the host. The most common
transactions will be uploading and downloading data, however any RPC that
requires payment will support receiving payment from an ephemeral account.

Each host has a separate set of ephemeral accounts, and each host is fully
trusted to honestly track the balances of the accounts. Users who keep ephemeral
accounts with a host will be able to verify themselves that a host is honestly
reporting the balance of an ephemeral account, however users have no recourse if
a host chooses to steal all of the money in an ephemeral account or otherwise
deny that the account exists. For this reason, users should only keep tiny
balances in ephemeral accounts and users should refill the ephemeral accounts
frequently, even on the order of multiple times per minute.

## Motivation

The main purpose of ephemeral accounts is to eliminate a key bottleneck in
download latency. The advantage it offers is that we can front-load our latency.
If it takes 6 hops and 2.5 seconds to pay host X, we can perform that payment in
advance of needing to download anything from host X by opening an ephemeral
account. That way, when we actually want to download data from the host, we can
enjoy downloading from the host in a single round trip that only needs to
communicate with the host, and we save ourselves from needing to do the 6 hop
routing in real time.

## Account

An ephemeral account is a balance linked to a pubkey. These accounts reside on
the host. The account owner fully entrusts the money with the host, he has no
recourse at all if the host decides to steal the funds. In order to spend from
the account, the sender must supply a signature from the account's pubkey. They
act as a payment mechanism.

The name 'ephemeral account' stems from the fact that hosts maintain a relaxed
consistency and durability of these accounts. This effectively enables us to do
perform the I/O asynchronously to the transaction, instead of needing to commit
a change before completing the transaction. This eliminates a key bottleneck in
download latency, and also enables much greater parallelism on downloads,
allowing a speed and flexibility that cannot be achieved with traditional
payment channels.

### Fingerprint

An ephemeral account supports two main actions that allow to deposit funds into
them, or allow to spend from them. When spending from an ephemeral account, a
hash of the message that was signed to authorize the payment is passed alongside
that spend. This hash is called a fingerprint. The host keeps track of these to
prevent a replay attack. The host wants to make sure each signature can only
spend money once. Fingerprints contain a field that specifies a blockheight at
which they expire.

Fingerprints with a blockheight that expired in the past, are not valid.
Fingerprints with a blockheight that is too far into the future, are not valid.
A fingerprint is considered too far into the future if it's expiry blockheight
exceeds that of the 'next' fingerprint bucket (see Persistence Model).

### Persistence Model

The data tied to an ephemeral account gets persisted in two separate parts. This
is due to their nature and how frequently they get updated. For every account we
want to keep track of the balance and the timestamp at which the account was
last updated. We also want to persist the fingerprints for every account, but we
persist those not on an account level, but across all accounts. Fingerprints are
persisted only to be loaded into a lookup table, so there is no need to keep
those per account.

All account balances are kept in a single accounts persist file. Because
accounts get updated so frequenty, it is infeasible to try and acquire a lock
and update this entire file on every update. For this reason, accounts are
fixed in size and get persisted to disk at a fixed location. This allows to
update an account's data without having to lock the entire file.

The fingerprints are kept in two files, which we will call 'buckets' from here
on out. Fingerprints expire at a certain blockheight, this means that we have to
keep track of them until that blockheight, and can safely purge them from those
buckets as soon as we've reached that blockheight. The buckets are called
'current' and 'next'.

The current bucket contains all fingerprints which expire within the current
block period. This period is calculated by dividing the current block height by
the size of the bucket, and rounding upward. So if bucketsize is 20, and current
blockheight is 34, the current block period is 20-40. Anything over 40 gets
persisted in the next bucket. Anything over 60 is considered too far into the
future.

It will be important to rotate in-memory fingerprints in a way that we can do it
in constant time. Anyhing less than that will prove way too slow in practice and
would lock up a host's CPU.

The persisting of these values happen asynchronously to the action being
performed on the account. A spend action can complete before the updated balance
hits the disk.

### Balance

Accounts have a maximum balance. This is a safety measure that protects the
host. If the host were to go offline, it would lose part of its state. Renters
could pick up on this and attempt to double spend. By limiting the maximum
account balance we protect the total amount of money the host is on the hook
for.

### Expiry

If an account has been inactive for a period of 7 days, the host will prune it
from his accounts list. This will effectively expire the account, along with all
the money that was associated to it.

Accounts expire due to their nature, the money that gets deposited into those
accounts is meant to be used almost instantaneously. It can not be expected of
hosts to keep track of these accounts for a long period of time. 7 days seems
more than fair.

### Blocking Spends

Spending from an ephemeral account is a potentially blocking action. It will
block when the account is not well enough funded to complete the action you are
trying to trigger. This block can be lifted either by a deposit, or by an
expiring timeout.

Calls get unblocked in the order they were enqueued, providing the deposit which
is unblocking them is large enough. If this is not the case, and the deposited
amount is less than the amount required to unblock the call that came in first, 
it will try to unblock the next.

## Host Settings

### Ephemeral Account Max Balance

The maximum ephemeral account balance is configurable through the internal host
setting called `MaxEphemeralAccountBalance`. It defaults to the
`SiacoinPrecision`, which is how many base units fit into a single siacoin,
which is 10^24.

### Max Unsaved Delta

Because we persist ephemeral accounts in an asynchronous manner, the total sum
of account balances a host has persisted to disk can differ from what it has in
memory at a single point in time. To mitigate the host's exposure, we cap this
risk by a host setting called `MaxUnsavedDelta`. This is the maximum delta in
siacoins that is waiting to be persisted to disk. When this maximum is reached,
all transactions halt until the updated balances are safely persisted to disk.