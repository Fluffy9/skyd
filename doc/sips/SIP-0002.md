# SIP-0002 Ephemeral Accounts

## Description

Ephemeral accounts are a service offered by hosts that allow users to connect a
balance to a pubkey. Users can deposit funds into an ephemeral account with a
host and then later use the funds to transact with the host. The most common
transactions will be uploading and downloading data, however any RPC that
requires payment will support receiving payment from an ephemeral account.

Each host has a separate set of ephemeral accounts, and each host is fully
trusted to honestly track the balances of the accounts. Users who keep ephemeral
accounts with a host will be able to verify themselves that a host is honestly
reporting the balance of an ephemeral account, however users have no recourse if
a host chooses to steal all of the money in an ephemeral account or otherwise
deny that the account exists. For this reason, users should only keep tiny
balances in ephemeral accounts and users should refill the ephemeral accounts
frequently, even on the order of multiple times per minute.

## Motivation

The main purpose of ephemeral accounts is to eliminate a key bottleneck in
download latency. The advantage it offers is that we can front-load our latency.
If it takes 6 hops and 2.5 seconds to pay host X, we can perform that payment in
advance of needing to download anything from host X by opening an ephemeral
account. That way, when we actually want to download data from the host, we can
enjoy downloading from the host in a single round trip that only needs to
communicate with the host, and we save ourselves from needing to do the 6 hop
routing in real time.

## Account

An ephemeral account is a balance linked to a pubkey. These accounts reside on
the host. The account owner fully entrusts the money with the host, he has no
recourse at all if the host decides to steal the funds. In order to spend from
the account, the sender must supply a signature from the account's pubkey. They
act as a payment mechanism.

The name 'ephemeral account' stems from the fact that hosts maintain a relaxed
consistency and durability of these accounts. This effectively enables us to do
perform the I/O asynchronously to the transaction, instead of needing to commit
a change before completing the transaction. This eliminates a key bottleneck in
download latency, and also enables much greater parallelism on downloads,
allowing a speed and flexibility that cannot be achieved with traditional
payment channels.

### Fingerprint

An ephemeral account supports two main actions that allow to deposit funds into
them, or allow to spend from them. When spending from an ephemeral account, a
hash of the message that was signed to authorize the payment is passed alongside
that spend. This hash is called a fingerprint. The host keeps track of these to
prevent a replay attack. The host wants to make sure each signature can only
spend money once. Fingerprints contain a field that specifies a blockheight at
which they expire.

### Persistence

An ephemeral account's persistence object falls apart into two separate parts.
For every account we want to keep track of the balance, but we also want to
persist the fingerprints related to that account.

The account balances are kept in a single file. It is infeasible to acquire a
lock and update this file on every account update. For this reason, accounts
are persisted on disk at a fixed size. This allows us to update the file at a
certain location in the file, opposed to having to update the entire file.

The fingerprints are kept in two files. Due to their expiring nature, we do not
want to keep track of fingerprints after they have expired. This means we will
store fingerprints in two buckets, the 'current' fingerprints and 'next'
fingerprints. Current will contain all fingerprints that expire within the
current block period.

The persisting of these values happen asynchronously to the action being
performed on the account. A spend action can complete before the updated balance
hits the disk.

It will be important to rotate in-memory fingerprints in a way that we can do it
in constant time. Anyhing less than that will prove way too slow in practice and
would lock up a host's CPU.

### Balance

Accounts have a maximum balance. This is a safety measure that protects the
host. If the host were to go offline, it would lose part of its state. Renters
could pick up on this and attempt to double spend. By limiting the maximum
account balance we protect the total amount of money the host is on the hook
for.

### Expiry

If an account has been inactive for a period of 7 days, the host will prune it
from his accounts list. This will effectively expire the account, along with all
the money that was associated to it.

Accounts expire due to their nature, the money that gets deposited into those
accounts is meant to be used almost instantaneously. It can not be expected of
hosts to keep track of these accounts for a long period of time. 7 days seems
more than fair.

### Blocking Spends

Spending from an ephemeral account is a potentially blocking action. It will
block when the account is not well enough funded to complete the action you are
trying to trigger. This block can be lifted either by a deposit, or by an
expiring timeout.

Calls get unblocked in the order they were enqueued, providing the deposit which
is unblocking them is large enough. If this is not the case, and the deposited
amount is less than the amount required to unblock the call that came in first, 
it will try to unblock the next.