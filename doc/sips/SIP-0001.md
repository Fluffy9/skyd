# SIP-0001 - Merklized Data Machine

SIP-0001 is a description of a virtual machine - the Merklized Data Machine
(MDM) - that executes instructions on the data in a Sia file contract. The file
contract tracks the size and Merkle root of the underlying data, which the MDM
will update when running instructions which modify the file contract data. Each
instruction can optionally produce a cryptographic proof that the instruction
was executed honestly. Every instruction has an execution cost, and instructions
are batched into atomic sets that are either entirely applied or not applied at
all. Each atomic set of instructions is called a program.

## Motivation and Rationale

The renter is required to perform increasingly sophisticated operations on the
host, especially as the renter is introducting new features such as garbage
collection, partial uploads, and file modifications. Further looking features
are even more complex than these.

Currently, each time the Sia team has chosen to add a new feature, the
renter-host protocol has needed an extension to support the feature. This not
only slows down Sia development, it presents a barrier to third parties looking
to develop novel applications on top of Sia.

The purpose of the MDM is to substantially increase the flexibility of the
renter-host protocol, enabling the renter to perform significantly more complex
behaviors and introduce novel ideas without needing any protocol extensions.
These more complex behaviors are enabled by a rich set of composable base
operations.

## Machine Specification

The Merklized Data Machine (MDM) is a virtual machine on a host that performs
operations on the data in a Sia file contract. The data in the contract is
tracked by a size and a Merkle root. The Sia consensus protocol breaks the
contract data into 64 byte 'segments', where each segment is a leaf of the
Merkle tree that builds into the Merkle root. As the MDM operates on the data,
the size and Merkle root of the file contract will be updated, and optionally
proofs can be produced proving that the operations were executed faithfully.

### Sectors

The MDM breaks the contract data into 4 MiB 'sectors'. A sector's Merkle root
can be computed by treating each of the 65,536 segments as a leaf in a Merkle
tree and combining them into the root. Because the sector root is computed using
the same leaves as the contract Merkle root, the sector roots can themselves be
used to compute the contract Merkle root. The MDM requires that the contract
size be a multiple of the sector size.

The host is explicitly expected to store all data within a sector continuously
on disk. Other than this requirement, contract data is not expected to be stored
continuously. This requirement allows the MDM to have predicatable performance
and a preditable execution cost, while allowing the host to optimize the
placement of multiple file contracts on disk.

The host maintains a lookup table that maps from each sector root to the
location on disk where the data is stored. This lookup table is global to the
entire host, allowing callers to query data by Merkle root even if the caller
does not have access to the contract that maintains the contract which manages
the sector.

The host itself does not have a mapping from sector root to the contract that
contains the sector. Sectors can be read by their Merkle root, however they
cannot be modified by their sector root.

### Programs

The MDM has 'instructions' that can be executed, each instruction performing a
distinct operation on the data. Every instruction starts with an initial Merkle
root and size and produces an updated Merkle root and size.

Instructions are batched together into a 'program'. Within a program, each
instruction will pass its updated Merkle root and file contract size to the next
instruction. The final instruction will pass the final Merkle root and contract
size to the MDM to be placed into an updated file contract revision that needs
to be signed by the host and by the contract owner.

As the program executes, each instruction will produce output to be sent to the
caller, taking the following form:

```go
type InstructionOutput struct {
	// If 'Success' is set to false, that indicates that the program has
	// terminated and that no more instructions will execute.
	Success bool

	// The error will be set to nil unless 'Success' is set to false.
	Error   error

	// The proof will be set to nil if there was an error, and also if no proof
	// was requested by the caller. Using only the proof, the caller will be
	// able to compute the next Merkle root and size of the contract.
	Proof   []crypto.Hash

	// The output will be set to nil unless the instruction produces output for
	// the caller. One example of such an instruction would be 'Read()'.
	Output  []byte
}
```

Instruction outputs will be encoded using the Sia encoding format, and will be
sent to the caller asynchronously as the program executes. The caller is able to
use the output to follow along with the program execution and verify the
correctness of the execution.

Though the outputs of the program are sent as the program executes,
modifications to the contract data are not committed until the caller has had
the chance to sign the final state of the contract following the termination of
the program. If the caller approves the final state of the contract data, all
changes will be committed atomically.

### Program Data

Each program has a data field, where a large amount of data can be placed. Most
instructions will draw their input from the data field, and multiple
instructions can use the same data as input.

Each instruction also has a set of operands. Most operands are just pointers to
areas in the data field where the actual input lies.

The following struct defines an instruction within a program.

```
type InstructionInfo struct {
	// The op code tells the MDM how to interpret the instruciton.
	OpCode        types.Specifier

	// The operands provide important input to the instruction. Most operands
	// are just pointers to the data field, where the real input is placed.
	Operands      []byte

	// If set to 'true', the InstructionOuput will contain a proof that allows
	// the caller to verify the execution of the instruction without needing the
	// file contract data.
	ProofRequired bool
}
```

### Execution

#### Read Mode and Write Mode

The MDM has two execution modes, a read-only mode and a read-write mode.
Read-only mode only has access to instructions that read data from a contract
without modifying it, and read-write mode has access to all MDM instructions.

Only one instance of read-write mode is allowed to be run at a time, and that
instance has exclusive write access to the file contract, meaning that the file
contract is inaccessible for other uses such as pay-by-contract.

Read-only MDMs are not exclusive, and read-only MDMs are even allowed to run
alongside read-write MDMs.

hrmph this is more challenging than I want >.<

challenging use case one: perform a sector root download while an upload is
happening. Don't want an exclusion lock here.

challenging use case two: a publisher is updating the same index that a user is
trying to read from. Probably need an exclusion lock here.

As many read-only MDMs are allowed to run in parallel as required, and read-only
MDMs are allowed to run alongside read-write MDMs. When a read-only MDM is
instantiated, a copy of the sector roots of the file contract is created, and
the read-only MDM will build proofs using that copy.

If a read-write MDM deletes or modifies data before the read-only MDM has a
chance to read it, the read-only MDM will return an error. The host is not
required 

### Tracking Resource Consumption

The MDM consumes resources on the host. To achieve fairness between programs and
protect the host against Denial of Service attacks, several resources are
tracked as the MDM executes, and each program is run with a limit for total
consumption of each resource.

Each instruction needs to be able to pre-compute the total resource requirements
for execution immediately prior to execution. If executing the instruction would
put the MDM over any of its resource limits, the instruction will be marked
unsuccessful and the program will halt with an error.

Five total resources are tracked. The host is able to price each resource, and
the resources are chosen to allow hosts to roughly put a fair price on the
execution of different types of programs even when each host is operating on
different types of hardware. The five resources are:

* Disk Accesses
* Disk Reads
* Disk Writes
* Memory Consumption
* Compute Power

With the exception of memory consumption, all resources are cumulative. As
instructions run, they add to the total amount of resources consumed.

Memory consumption is special. The initial memory cost of a program is the size
of the encoded instructions plus the size of the data field. If an instruction
allocates additional memory, that memory is added to the initial memory size,
and the total memory consumption of the program is only updated if the
instruction's allocations + the initial memory are larger than the current
memory consumption of the program. Stated another way, the memory consumption
only tracks the maximum amount of memory that is in use for any of the
instructions.

Instantiating the MDM has the following costs:

* Disk Access:         1 access
* Disk Read:           0 bytes
* Disk Write:          0 bytes
* Memory Consumption:  len(encodedInstructions) + len(programDataField) bytes
* Compute Power:       1 unit

### Interruption

A program being executed can be interrupted. If an interrupt signal is received,
the host will attempt to abort the program, reverting all changes and accepting
the interrupt. It may be the case that an interrupt is received after a program
has been fully comitted, and can no longer be reverted. If this happens, the
host will reject the interrupt. Rejecting the interrupt is not an error, both
acceptance and rejection of an interrupt are considered successful calls. The
full cost of the program will be applied even if the program is interrupted
early.

If an interrupt is received, no additional data will be returned to the user,
and any data currently being sent to the user will be aborted.

## Program Format

The MDM is always called using program at a time.

```go
type MerkleRoot crypto.Hash

type MerkleProof []crypto.Hash

// InstructionSerialization contains a generic instruction serialized for the
// MDM. The OpCode indicates which instruction should be used. The operands are
// all of the information required to compute the cost of executing the
// instruction and the resulting size of the contract data.
//
// The operands are required to be under 4 kib total, any larger inputs need to
// be placed in the program data.
type InstructionInfo struct {
	OpCode        types.Specifier
	Operands      []byte
	ProofRequired bool
}

// Instruction defines the set of methods required to build, cost, and execute
// an instruction within the MDM. The instruction itself should be stateless,
// all required inputs are provided in the interface.
type Instruction interface {
	// The initialSize and the inputs should be the only information required to
	// compute the cost of executing the instruction and the resulting size of
	// the file.
	//
	// Size is necessary to compute in advance for two reasons. The first is
	// that in some cases, for example with proof generation, the size can have
	// an impact on the final cost. The second is that the host needs to be able
	// to tell if there is enough disk space available to execute all of the
	// instructions.
	CostAndSize(initialSize uint64, proofRequired bool, operands []byte) (*MDMCost, uint64)

	// The instruction is executed on file 'f', mutating the state of 'f' in a
	// way that can be reverted if a future instruction in the batch fails. If
	// the instruction has no output, 'output' will be nil even for a successful
	// execution. If no proof is requested, 'proof' will be 'nil' even for a
	// successful execution.
	//
	// Execute is allowed to modify the programData, the changes will be visible
	// to all future instructions.
	Execute(env *environment, operands []byte, proofRequired bool, programData []byte) (output []byte, proof []byte, err error)
}

// Authorization of the program is assumed to have already happened by the time
// the MDM is initialized.
type Program struct {
	Code []InstructionInfo
	Data []byte
}

// When a program has terminated, this data is sent to the user.
type ProgramOutput struct {
	FinalMerkleRoot MerkleRoot
	FinalSize       uint64

	// These slices are the same size as the input slices, one element per
	// instruction. Some of the elements of each slice may be 'nil' if there is
	// no ouptut or proof for that instruction.
	//
	// Each proof should enable a verifier to chain a previous intermediate
	// merkle root to an updated intermediate Merkle root. The very first
	// intermediate root is the starting root of the file contract, and the
	// final intermediate root should match the FinalMerkleRoot of the program 
	// output.
	InstructionOutputs [][]byte
	InstructionProofs  []MerkleProof
}

// The MDMCost is the cost of executing an MDM instruction or program.
type MDMCost struct {
	DiskAccesses uint64
	DiskReads    uint64
	DiskWrites   uint64
	ComputePower uint64
}

// Add will add the costs of x and y together, placing the result in z and
// returning z.
func (z *MDMCost) Add(x, y *MDMCost) *MDMCost {
	z.DiskAccesses = x.DiskAccesses + y.DiskAccesses
	z.DiskReads = x.DiskReads + y.DiskReads
	z.DiskWrites = x.DiskWrites + y.DiskWrites
	z.ComputePower = x.ComputerPower + y.ComputePower
	return z
}

// CostAndSize reports the cost of executing a program and the resulting size of
// the file from executing the program.
//
// The size following the execution of a program is needed so that the host can
// verify before execution that there is enough space available.
func (p *Program) CostAndSize() MDMCost {
	totalCost := new(MDMCost)
	size := initialSize
	for _, ii := range bi.Instructions {
		i := getInstruction(ii.OpCode) // Fetches the instruction object associated with the instruction name.
		newCost, newSize := i.CostAndSize(size, i.Inputs, i.ProofRequired)
		size = newSize
		totalCost.Add(totalCost, newCost)
	}
	c.ComputePower++ // Cost of initializing a batch of instructions.
	return c, size
}

func (p *Program) Execute(env *environment) (ProgramOutput, error) {
	var po ProgramOutput
	for _, ii := rangebi.Instructions {
		i := getInstruction(ii.OpCode)
		iOutput, iProof, err := i.Execute(env, ii.Operands, ii.ProofRequired, p.Data)
		if err != nil {
			return ProgramOutput{}, err
		}
		po.InstructionOutputs = append(po.InstructionOutputs, iOutput)
		po.InstructionProofs = append(po.InstructionProofs, iProof)
	}
	env.commit()
	return ProgramOutput, nil
}
```

The MDM is always instantiated with a list of instructions followed by a list
inputs for each instruction.

## Supported Instructions

Notation: the instructions are written as functions that take multiple variables
as input. The variables are assumed to have an obvious encoding into the
operands. If instruction requires an interaction with the program data, the
variable will be prefixed by 'pd'. If the instruction writes to the program
data, the destination will be a []byte prefixed by 'wpd'. The operands will also
need to include information about where to find the 'pd' and 'wpd' variables
within the program data.

If the instruction has data output that is sent to the user, the instruction
definition will return a []byte.

TODO: Formal specification for encoding instruction inputs into operands.

### Read(length uint64, pdOffset uint64) []byte

Read will read 'length' bytes from the contract, starting from the provided
offset. The request must exist fully within the bounds of the contract.

The output of Read is the 'length' bytes that appear in the contract starting
from the provided offset.

Cost:
* Disk Accesses:    2 + (length / sectorSize)
* Disk Read:        length
* Disk Write:       0
* Computation Cost: log2(contractSize/64)

### ReadSector(length uint64, pdOffset uint64, pdRoot crypto.Hash) []byte

ReadSector will read data from the sector with the sector root 'root'.
ReadSector will read 'length' bytes from the sector starting from the provided
offset. The request must exist fully within the bounds of the sector.

The output of ReadSector is the 'length' bytes that appear in the sector
starting from the provided offset.

Cost:
* Disk Accesses:    1
* Disk Read:        length
* Disk Write:       0
* Computation Cost: log2(contractSize/64)

### Write(pdOffset uint64, pdData []byte)

Write will write 'pdData' at offset 'offset' within the contract, overwriting
any data that already exists at that location. Write must not go beyond the
bounds of the existing file contract data.

Cost:
* Disk Accesses:    2 + (len(pdData) / sectorSize)
* Disk Read:        0
* Disk Write:       len(pdData)
* Computation Cost: log2(contractSize/64)

### WriteSector(root crypto.Hash, offset uint64, pdData []byte)

Write will write 'pdData' at offset 'offset' within the sector, overwriting any
data that already exists at that location. Write must not go beyond the bounds
of the sector.

Cost:
* Disk Accesses:    1
* Disk Read:        len(pdData)
* Disk Write:       0
* Computation Cost: log2(contractSize/64)

### Copy(size, destOffset, sourceOffset uint64)

Copy will copy the data from sourceOffset to destOffset, overwriting existing
data. Copy cannot copy outside the boundary of the existing file contract.

Cost:
* Disk Accesses:    4 + 2 * (size / sectorSize)
* Disk Read:        size
* Disk Write:       size
* Computation Cost: 2 * log2(contractSize/64)

### CopySector(size, destOffset, sourceOffset uint64, destRoot, sourceRoot crypto.Hash)

CopySector will copy data from the sourceRoot at the sourceOffset to the
destRoot at the destOffset. The copy is not allowed to go outside the range of
either sector.

Cost:
* Disk Accesses:    2
* Disk Read:        size
* Disk Write:       size
* Computation Cost: 2 * log2(contractSize/64)

### Swap(size, offset1, offset2 uint64)

Swap will read data from offset1, then read data from offset2, then write the
data from offset1 to offset2, then write the data from offset2 to offset1.

TODO: Should the offsets be allowed to overlap? Probably not.

Cost:
* Disk Accesses:    4 + 2 * (size / sectorSize)
* Disk Read:        size
* Disk Write:       size
* Computation Cost: 2 * log2(contractSize/64)

### Truncate(newSize uint64)

Truncate will change the size of the contract data to be equal to the newSize,
throwing away data on the tail of the file if the new size is smaller, and
appending zeroes to the end of the contract data if the new size is larger. If
newSize is equal to the current size of the contract data, this instruction is a
no-op.

'newSize' must be a multiple of the sectorSize.

Cost:
* Disk Accesses:    1
* Disk Read:        0
* Disk Write:       0
* Computation Cost: log2(contractSize/64)

### RenewContract()

TODO: This operation has extra overheads + costs, not sure how to handle that.
We need Renew to be inside of the MDM because the new file contract needs to be
created atomically with dropping garbage sectors. The renew operation also needs
to zero out the data in the previous contract / previous revision, and that
needs to happen in a single transaction.

Cost:
* Disk Accesses:    1
* Disk Read:        0
* Disk Write:       0
* Computation Cost: log2(contractSize/64)

## Example Programs

### Delete A Sector

This program deletes sector 7 from a contract with 250 sectors, where the final
49 sectors are garbage. Metadata in the leading sector needs to be updated to
indicate the new length of the garbage.

Instructions {
	Swap(2^22, 7*2^22, 200*2^22)
	Write(4096, payload[:4096])
}

### TODO: Write a similar program as above

except read from the metadata to know where the swap should happen. This may
result in the swap operands being modified - the size needs to be an operand,
but offset1 and offset2 could actually be payload variables. Another instruction
could read from the metadata and then modify the payload to tell swap how to
swap out the garbage.

### Renew a File Contract with Garbage

This program renews a file contract that has 250 sectors, but the final 50
sectors are garbage.

Instructions {
	Truncate(200*2^22)
	Renew()
}

### TODO:

Write some program that relates to updating multiple contracts simultanously,
preserving ACID properties. Or maybe some program that would be related /
necessary to doing continuous backup.

### TODO:

Write some program related to filesystem trasversal, such that the renter can
read data without needing multiple round trips.
