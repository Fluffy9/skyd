# SIP-0003: Fund Ephemeral Account RPC

## Description

SIP-0003 introduces a new RPC call which allows funding an ephemeral account. An
ephemeral account (see SIP-0002) is an off-chain balance kept by the host, and
can be used as payment method. This SIP will propose an RPC which allows funding
such an account. There are two ways to fund an ephemeral account. Either it is
funded through direct payment, which is made through a contract that is shared
between caller and host, or it's funded through another ephemeral account.

## Motivation

Ephemeral accounts are a payment method that allow making payment without
requiring any disk I/O on the host. Amongst a lot of other things this allows
speedy downloads. We need this for CDN and file sharing use cases. For an
account to be useful, it needs to be funded, which is the behind this SIP.

## Key Differences

The current "new RPC" methods are part of the rpc loop. This loop is able to
perform multiple data operations atomically within the same request. This is
going to be replaced by a better system, called the MDM, which is outlined in
SIP-0001.

The fund ephemeral account RPC will be fundamentally different. It will be
simpler in the sense it will only take in a connection, which the host can
assume is multiplexed and encrypted. There will be no need to interact with a
contract, so we won't need to acquire a lock and deal with storage obligations
in an RPC session any more.

The whole point of ephemeral accounts, which is also where it got its name, is
that they eliminate the disk I/O which currently would be a bottleneck and gets
in the way of super fast downloads.

## Payment Method Types

Ephemeral accounts are a form of payment. Payable RPCs will need to be preceded
by a process, following a request/response pattern, which takes care of the
payment for any subsequent requests.

There will be two types of payment methods.

The first type is direct payment, this means payment through a file contract
revision. This type of payment is not new and is currently how renters pay
hosts.

The second type of payment is ephemeral account payment. This payment method is
potentially blocking in nature, as it can pay from an unknown or unfunded
account. In this case the RPC call will block and await a potential deposit. It
will timeout after a certain period of time and these RPC calls will be
rate limited, to protect the host from a potential DoS attack.

```Go
var (
    SpecifierPaymentMethodDirect = Specifier{'d', 'i', 'r', 'e', 'c', 't'}
    SpecifierPaymentMethodEphemeralAccount = Specifier{'e', 'p', 'h', 'e', 'm',
    'e', 'r', 'a', 'l', 'a', 'c', 'c', 'o', 'u', 'n', 't', }
)
```

## Design

The payment RPC will most probably reuse the current RPC loop functionality. We
need this loop design to allow for a payment step which is then followed by an
arbitrary amount of requests that have been prepaid and refer to an ephemeral
account from which we can spend.

The following is a series of request/response types which describe the payment
process in detail. Some of them are new but most of them reuse the
request/response structs we know from the renter-host protocol.

It is important to note that the first RPC ID sent will be the `RPCLoopEnter`.
As a first step it performs a key exchange between the two parties. For this we
can simply reuse the `LoopKeyExchangeRequest` and `LoopKeyExchangeResponse`.
This obtains a cipher which we'll use to encrypt further communications.

After entering the RPC loop, the next RPC ID needs to signal we want to make a
payment. This will fund the ephemeral account which can be used as payment for
any consecutive RPCs.

```Go
// Fund ephemeral account RPC ID
var RPCLoopFundEphemeralAccount = types.Specifier{'F', 'u', 'n', 'd', 'E', 'p',
'h', 'e','m', 'e', 'r', 'a', 'l', 'A', 'c', 'c'}


// LoopFundEphemeralAccountRequest contains the request parameters for
// RPCLoopFundEphemeralAccount.
LoopFundEphemeralAccountRequest struct {
    PaymentMethod       types.Specifier
    PaymentInstructions []PaymentInstruction
    PaymentDetails      PaymentDetails
}

// PaymentInstruction contains the details of every separate payment
PaymentInstruction struct {
    AccountID types.SiaPublicKey
    Amount    types.Currency
}

PaymentDetails struct {
    // DirectPayment fields
    ContractID        types.FileContractID
    ContractSignature []byte
    LockTimeout       uint64

    // EphemeralAccount fields
    AccountID types.SiaPublicKey

    Signature []byte
}

// LoopFundEphemeralAccountRequest contains the response data for
// RPCLoopFundEphemeralAccount.
LoopFundEphemeralAccountResponse struct {
    Acquired     bool
    NewChallenge [16]byte
    Revision     types.FileContractRevision
    Signatures   []types.TransactionSignature
}

// LoopMakeDirectPaymentRequest contains the request data for making a direct
// payment
LoopMakeDirectPaymentRequest struct {
    NewRevisionNumber    uint64
    NewValidProofValues  []types.Currency
    NewMissedProofValues []types.Currency
    Signature            []byte
}

// managedRPCLoopFundEphemeralAccount handles the payment RPC request/response
// flow
func (h *Host) managedRPCLoopFundEphemeralAccount(s *rpcSession) error
}
```

Upon entering the `managedRPCLoopFundEphemeralAccount` there will be a
request/response exchange of `LoopFundEphemeralAccount` structs. There are two
possible flows here which depend on the payment method which is part of the
initial request.

If the payment method specifies direct payment, we can fall back on existing
code for the most part. We will need to get hold of a contract id, acquire a
lock and then negotiate a new contract revision. We won't need to introduce any
new types for this.

If the payment method specifies an ephemeral account payment, the initial
request holds all information we require. We do not need to lock anything and we
can try to spend from the specified we can try and
spend from the account. using `callSpend(id string, amount types.Currency, fp crypto.Hash)`

The first thing we will need is an RPC ID that identifies we want to make
payment. Making a payment is essentially the same as saying "fund ephemeral
account" as the balances are kept by those accounts.





It is important to note that the first RPC ID sent will be the `RPCLoopEnter`.
The first step is a key exchange between the two parties. For this we can simply
reuse the `LoopKeyExchangeRequest` and `LoopKeyExchangeResponse`. This obtains a
cipher which we'll use to encrypt further communications. Up until now 

- The second step 
The payment RPC
## Design

```Go
// Fund Ephemeral Account Specifier
RPCFundEphemeralAccount = types.Specifier{'F', 'u', 'n', 'd', 'E', 'p', 'h', 'e'
,'m', 'e', 'r', 'a', 'l', 'A', 'c', 'c'}

// managedRPCFundEphemeralAccount is responsible for handling an RPC request
// from the caller (not necessarily a renter) that will deposit a certain amount
// of money into a specified ephemeral account
func (h *Host) managedRPCFundEphemeralAccount(conn net.Conn) error
```
