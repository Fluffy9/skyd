# SIP-0002 Ephemeral Accounts

## Description

Ephemeral accounts are nothing more than balances tied to pubkeys. These
accounts are kept on the host, they manage these accounts and allow users to
fund them, or use them to forward money to other hosts. In theory they can be
used as a payment method for every payable RPC.

It is important to note that these accounts require fully trusting the host. The
host can at any point in time go offline and run away with the money. We protect
ourselves by limiting the total amount of money such an account can hold, and
by using packetized payments. Usually the amounts of money we entrust with a
host are very small, not more than the price of a partial download.

## Motivation

By enabling RPCs to be paid from such an ephemeral account, we avoid the
necessity of having to go to disk for every action we want to trigger on a host.
Which is currently the case as it requires contract revisions to be fsynced.

Furthermore, they allow routing payment through the network. By funding these
accounts and then instructing the host to forward it to another host we
essentially build a payment network. This allows paying hosts with which you do
not necessarily share a payment link and forms the basis for payment routing.

## Account

An ephemeral account is a balance linked to a pubkey. These accounts reside on
the host. The account owner fully entrusts the money with the host, he has no
recourse at all if the host decides to steal the funds. In order to spend from
the account, the sender must supply a signature from the account's pubkey. They
act as a payment mechanism.

We name them ephemeral accounts because the whole point of them is to avoid the
necessity for disk I/O which is slow. By allowing users to spend from an
ephemeral account we avoid an otherwise necessary fsync (to update the
contract). Further more, when money is deposited into the account, it is meant
to be spent almost instantaneously. At least in a very short time span, which is
also why we expire the accounts after a relatively short period of time.

### Balance

Accounts have a maximum balance. This is a safety measure that protects the
host. If the host were to go offline, it would loose part of its state. Renters
could pick up on this and attempt to double spend. By limiting the maximum
account balance we protect the total amount of money the host is on the hook
for.

### Persistence

Ephemeral accounts are persisted by the host. However the host does not give any
guarantees. To avoid having to lock too often and go to disk, an account is only
persisted when its balance increases.

### Expiry

If an account has been inactive for a period of 7 days, the host will prune it
from his accounts list. This will effectively expire the account, along with all
the money that was associated to it.

Accounts expire due to their nature, the money that gets deposited into those
accounts is meant to be used almost instantaneously. It can not be expected of
hosts to keep track of these accounts for a long period of time. 7 days seems
more than fair.

### Blocked Call

Spending from an ephemeral account is a potentially blocking action. It will
block when the account is not well enough funded to complete the action you are
trying to trigger. This block can be lifted either by a deposit, or by an
expiring timeout.

Calls get unblocked in the order they were enqueued. If the deposited amount is
not big enough, it will try the next blocked call. A blocking call that requires
a large amount to be deposited will not block the unblocking of later calls that
require less money.

```Go
// blockedCall represents a waiting thread due to insufficient balance upon 
// deposit these calls get unblocked if the amount deposited was sufficient
type blockedCall struct {
    id       string
    unblock  chan struct{}
    required types.Currency
}

// blockedCallTimeout is the maximum amount of time a call is blocked
var blockedCallTimeout = build.Select(build.Var{
    Standard: 15 * time.Minute,
    Dev:      15 * time.Second,
    Testing:  3 * time.Second,
}).(time.Duration)
```

## Fingerprint

A fingerprint (for lack of a better term), is  a hash of the message that was
signed to authorize the payment. The host keeps track of these to prevent a
replay attack. The host wants to make sure each signature can only spend money
once.

These fingerprints do not get persisted. This is why account balances need to be
capped, the host is on the hook for all of the money in its ephemeral accounts.
Seeing as the fingerprints are not persisted, it is susceptible to replay
attacks if it goes offline and might loose a lot of money if we do not cap the
account balances.

## Subsystems

### Account Manager

The account manager will be a new subsystem of the host. It keeps track of all
ephemeral accounts balances.

```Go
// accountManager is a subsystem that manages all ephemeral accounts.
//
// These accounts are a pubkey with a balance associated to it. They are
// kept completely off-chain and serve as a method of payment.
//
// The account owner fully entrusts the money with the host, he has no
// recourse at all if the host decides to steal the funds. Because of that,
// the total amount of money an account can hold is capped.
//
// All operations on the account have ACID properties.
accountManager struct {
    accounts     map[string]types.Currency
    updated      map[string]int64
    fingerprints map[crypto.Hash]struct{}
    blockedCalls []blockedCall

    mu           sync.Mutex
    persister    *accountsPersister
    dependencies modules.Dependencies
    *hostUtils
}

// callSpend will try to spend from an account, it blocks if the account balance
// is insufficient
func (am *accountManager) callSpend(id string, amount types.Currency,
fp crypto.Hash) error

// callDeposit will credit the amount to the account's balance, it will
// then scroll through all blocked calls and unblock where possible
func (am *accountManager) callDeposit(id string, amount types.Currency) error
```

### Account Persister

The account persister is a separate subsystem, this to separate both mutex
domains.

```Go
type (
    // accountsData contains all account manager data we want to persist
    accountsData struct {
        Accounts     map[string]types.Currency
    }

    // accountsPersister is a subsystem that will persist all account data
    accountsPersister struct {
        location     string
        mu           sync.Mutex
        dependencies modules.Dependencies
        hostUtils
    }
)
```
